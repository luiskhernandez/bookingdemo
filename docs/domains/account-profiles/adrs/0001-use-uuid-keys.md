# ADR-0001: Use UUID Primary Keys

## Status
Accepted

## Context
We need to decide on the primary key strategy for our database tables. The main options are:
1. Traditional auto-incrementing integers
2. UUIDs (Universally Unique Identifiers)

## Decision
We will use UUIDs as primary keys for all tables in the application.

## Consequences

### Positive
- **No ID enumeration attacks**: External actors cannot guess or iterate through record IDs
- **Distributed generation**: IDs can be generated by the application without database round-trips
- **Merge-friendly**: Multiple environments can create records without ID conflicts
- **Future-proof**: Easier to implement distributed systems or microservices later
- **No information leakage**: Sequential IDs can reveal business metrics (user count, order volume)

### Negative
- **Storage overhead**: UUIDs (16 bytes) use more space than integers (4-8 bytes)
- **Index performance**: Slightly slower index performance due to size and randomness
- **Readability**: UUIDs are harder to read and remember during debugging
- **URL length**: Longer URLs when IDs are exposed in routes

## Implementation
```ruby
# config/application.rb
config.generators do |g|
  g.orm :active_record, primary_key_type: :uuid
end

# Migration example
class CreateUsers < ActiveRecord::Migration[8.0]
  def change
    create_table :users, id: :uuid do |t|
      # columns...
    end
  end
end
```

## References
- PostgreSQL UUID documentation
- Rails UUID guide
- Security best practices for web applications